# -*- coding: utf-8 -*-
"""Cópia de LabCPD-04-Python.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1sB7I0PUYdEzJQ23LUNqQixIXJoOoooRX

# Disciplina de Classificação e Pesquisa de Dados
 
# Laboratório #4
 
### Implementação (em Python) de estratégias e funções relacionados com estruturas Hash

O objetivo consiste em usar os mecanismos de dicionário oferecidos pela linguagem Python 3 ou superior para armazenar e consultar informações, além de verificarmos o funcionamento de algumas técnicas de tratamento de colisões e de redimencionamento de tabelas. Em seguida, vamos implementar algumas funções de geração de códigos hash para diferentes tipos de dados.

Se possível, estude como Python implementa internamente um dicionário. Também avalie que tipos de estruturas semelhantes outras linguagens oferecem (p.ex., hash tables em Java/C# e arrays associativos em C++).

----------------
## I) Python Dicts

Python oferece uma estrutura de dados muito utilizada chamada de dicionário. Essa estrutura é implementada internamente usando as técnicas de hash que vimos em aula.

Seguem alguns exemplos abaixo.
"""

# cria um dicionário vazio:
dicionario1 = {}

# cria um dicionário cujas chaves são números
dicionario2 = {1: 'bananas', 2: 'maças', 5: 'peras'}

# dicionário com chaves alfanuméricas (ou mixtas):
dicionario3 = {'nome': 'Leonardo', 1: [2, 4, 3]}

# criando usando compreensions:
odd_squares = {x: x*x for x in range(11) if x%2 == 1}

# Adicionando itens no dicionário:
dicionario1['leandro'] = {'status':'professor', 'lotacao': 'CINTED'}

# consulta ao dicionário:
print(dicionario1['leandro'])

print(dicionario2[1])

print(dicionario3['nome'])

print(dicionario3[1])

print(odd_squares)

# removendo um item:
dicionario3.pop(1)
print(dicionario3[1]) # erro porque a chave não existe mais!

# apagando tudo em um dicionário:
dicionario2.clear()
print(dicionario2[1]) # erro porque não tem mais nada!

"""---------------
## 2) SimpleHashTable

Agora vamos analisar uma implementação simples de tabelas hash que usam a função módulo para gerar código hash (posição/endereço em uma tabela ou array) e a técnica de sondagem linear (linear probing) para tratar colisões.

Observe o código abaixo e seu teste de uso com diferentes exemplos.
"""

class SimpleHashTable:
    # construtor, basta passar tamanho inicial da tabela hash
    def __init__(self, size):
        self.size = size
        self.dicionario = [-1] * size                 # -1 significa que o local está vago
        self.conteudo   = [None] * size 
        self.used       = [False] * size
        self.old = [True] * size
        self.free = [True] * size
        self.Realocado = [False] * size
        self.Ocupado = [False] * size
        self.status = ''             
        
    def add(self, chave, dado):
        posicao = posicao_inicial = chave % self.size # usa o módulo
        
        if self.dicionario[posicao] == -1:            # se estiver vazio
            self.dicionario[posicao] = chave          # coloca a chave
            self.conteudo[posicao] = dado                      # associa dado
            self.used[posicao] = True
            self.old[posicao] = True
            self.free[posicao] = False
            self.Ocupado[posicao] = True
            return posicao
        else:                                         # se estiver ocupado, tenta achar lugar usando linear probing
            first_pass = True
            while posicao != posicao_inicial or first_pass:
                first_pass = False
                posicao = (posicao + 1) % self.size   # incrementa posição (mas fica dentro do intervalo do array de chaves)
                if self.dicionario[posicao] == -1:    
                    self.dicionario[posicao] = chave  
                    self.conteudo[posicao] = dado
                    self.used[posicao] = True
                    return posicao   
        if posicao == posicao_inicial:                  # se posicao igual à inicial é porque fez a volta e não achou
            return -1                                  # informa que deu problema (está cheio)
        else:   
            return posicao                             # retorna posição onde colocou o dado
    
    def get(self, chave):
        posicao_inicial = posicao = chave % self.size
        first_pass = True
        
        # busca elemento usando linear probing:
        while self.dicionario[posicao] != chave and self.used and (posicao_inicial != posicao or first_pass):
            first_pass = False
            posicao = (posicao + 1) % self.size
            
        if self.dicionario[posicao] == chave:
            return self.conteudo[posicao]
        else:
            return None # se chegou aqui é porque não existe a chave
    
    def remove(self, chave):
        posicao_inicial = posicao = chave % self.size
        first_pass = True
        
        # busca elemento usando linear probing:
        while self.dicionario[posicao] != chave and self.used and (posicao_inicial != posicao or first_pass):
            first_pass = False
            posicao = (posicao + 1) % self.size
            
        if self.dicionario[posicao] == chave:
            self.dicionario[posicao] = -1
            self.conteudo[posicao] = None
            return posicao
        else:
            return None # se chegou aqui é porque não existe a chave
        return -1

    # modifica tamanho da tabela criando nova tabela
    def resize_on_new(self, novo_tamanho):
        hash_table2 = SimpleHashTable(novo_tamanho)
        first_pass = True
        posicao = posicao_inicial = 0
        posicao = (posicao) % self.size
        while posicao != posicao_inicial or first_pass:
            first_pass = False
            if self.dicionario[posicao] != -1:    
              chave = self.dicionario[posicao]  
              dado = self.conteudo[posicao]
              self.used[posicao] = False
              hash_table2.add(chave, dado)
              posicao = (posicao + 1) % self.size   # incrementa posição (mas fica dentro do intervalo do array de chaves)
            else:
              posicao = (posicao + 1) % self.size   # incrementa posição (mas fica dentro do intervalo do array de chaves)
            
        if posicao != posicao_inicial:                  # se posicao igual à inicial é porque fez a volta e não achou
            return -1                                  # informa que deu problema (está cheio)
        else:
            return hash_table2       

    # modifica tamanho da tabela nela mesmo
    def resize_in_situ(self, novo_tamanho):
        stackC = []
        stackD = []
        for i in range(self.size, novo_tamanho):
            self.dicionario.append(-1)
            self.conteudo.append(None)
            self.used.append(False)
            self.free.append(True)
            self.Ocupado.append(False)
            self.Realocado.append(False)
            self.old.append(False)

        self.size = size = novo_tamanho
        posicao = posicao_inicial = 0
        first_pass = True
        posicao = (posicao) % self.size


        
        for posicao1 in self.dicionario:
            posicao = (posicao1) % self.size
            if posicao_inicial != posicao or first_pass:
              first_pass = False
              if self.dicionario[posicao] != -1:
                self.Ocupado[posicao] = True
                posicao = (posicao + 1) % self.size
              else:
                self.free[posicao] = True
                posicao = (posicao + 1) % self.size
              

        posicao = posicao_inicial = 0
        first_pass = True
        posicao = (posicao) % self.size
        for posicao1 in self.dicionario:
            first_pass = False
            posicao = (posicao1) % self.size
            if self.Ocupado[posicao]:
              chave = self.dicionario[posicao]
              dado = self.conteudo[posicao]
              stackC.append(chave)
              stackD.append(dado)
              self.remove(chave)
              self.free[posicao] = True
              self.Ocupado[posicao] = False
              self.Realoc(stackC, stackD)
              posicao = (posicao + 1) % self.size
            else: 
              posicao = (posicao + 1) % self.size

        return self

    def Realoc(self, stackC, stackD):
        if len(stackC) != 0:
            chave = stackC.pop()
            dado = stackD.pop()
            posicao = posicao0 = chave % self.size
            umavez = True
            if self.Realocado[posicao]:
                posicao = self.add(chave,dado)
                self.used[posicao] = True
                self.old[posicao] = False
                self.free[posicao] = False
                self.Realocado[posicao] = True
                self.Realoc(stackC, stackD)

            if self.Ocupado[posicao] == True:
                stackC.append(chave)
                stackD.append(dado)
                chave = self.dicionario[posicao]
                dado = self.conteudo[posicao] 
                stackC.append(chave)
                stackD.append(dado)
                self.remove(chave)
                self.free[posicao] = True
                self.Ocupado[posicao] = False
                self.old[posicao] = False
                self.Realoc(stackC, stackD)
            else:   
                if self.free[posicao] == True:
                  self.dicionario[posicao] = chave          # coloca a chave
                  self.conteudo[posicao] = dado                      # associa dado
                  self.used[posicao] = True
                  self.old[posicao] = False
                  self.free[posicao] = False
                  self.Realocado[posicao] = True
                  self.Realoc(stackC, stackD)
        else:
            return self
    
    def add2(self, chave, dado):
        posicao = posicao_inicial = chave % self.size # usa o módulo
        
        if self.dicionario[posicao] == -1:            # se estiver vazio
            self.dicionario[posicao] = chave          # coloca a chave
            self.conteudo[posicao] = dado                      # associa dado
            self.used[posicao] = True
            self.old[posicao] = True
            self.free[posicao] = False
            self.Ocupado[posicao] = True
            return posicao
        else:                                         # se estiver ocupado, tenta achar lugar usando linear probing
            first_pass = True
            while posicao != posicao_inicial or first_pass:
                first_pass = False
                posicao = (posicao + 1) % self.size   # incrementa posição (mas fica dentro do intervalo do array de chaves)
                if self.dicionario[posicao] == -1:    
                    self.dicionario[posicao] = chave  
                    self.conteudo[posicao] = dado
                    self.used[posicao] = True
                    return posicao   
        if posicao == posicao_inicial:                  # se posicao igual à inicial é porque fez a volta e não achou
            return -1                                  # informa que deu problema (está cheio)
        else:   
            return posicao                             # retorna posição onde colocou o dado

    def print(self):
        for indice in range(0, self.size):
            print(f"({indice:03d})[{self.dicionario[indice]:03d}] = {str(self.conteudo[indice]):15s} ({self.used[indice]}) ({self.free[indice]})")

"""Abaixo veja alguns exemplos de uso:"""

#cria uma estrutura com 20 posições
hash_table = SimpleHashTable(13)

# mostra estrutura interna da hashtable
hash_table.add(0, "valor 1")
hash_table.add(1, "valor 2")
hash_table.add(2, "valor 2")
hash_table.add(6, "valor 2")
hash_table.add(22, "valor 2")
hash_table.add(46, "valor 2")
hash_table.add(73, "valor 2")
hash_table.add(69, "valor 2")
hash_table.add(188888, "valor 2")
hash_table.add(197, "valor 2")
hash_table.add(215, "valor 2")

hash_table.print()

# adiciona uma chave e dados associados:
#hash_table.add(8, "valor 9")
#hash_table.add(6, "valor 6")
#hash_table.add(1, "valor 1")
#hash_table.add(3, "valor 3")

hash_table = hash_table.resize_in_situ(31)
hash_table.print()

# adiciona uma chave e dados associados:
hash_table.add(101, "valor n3w")
hash_table.print() # mostra como ficou a estrutura interna

hash_table.add(20, "valor 20")
hash_table.print()

hash_table.add(0, "valor 0")
hash_table.print()

hash_table.add(12, "valor 12")
hash_table.print()

# recupera o dado associado com a chave 0:
print(hash_table.get(0))

# recupera dado associado com chave 10:
print(hash_table.get(10))

# remove elemento de chave 10:
print(hash_table.remove(10))

hash_table.print()

print(hash_table.get(10)) # removeu e portanto não retorna nada

"""Vamos agora analisar a diferença entre usar um número primo como tamanho para a tabela ou outro número qualquer.

O primeiro exemplo adiciona 4 números que possuem divisores comuns (entre si e entre o tamanho da tabela). Perceba que há concentração e todos caem na mesma posição.

O segundo exemplo usa um número primo, aumentando as chances de não ocorrer concentração, visto que não há mais propriedades comuns (divisores, no caso) entre os números e o tamanho da tabela.
"""

# cria dicionario com tamanho não primo
hash_table = SimpleHashTable(10)
hash_table.add(10, 10)
hash_table.add(20, 20)
hash_table.add(30, 30)
hash_table.add(40, 40)
hash_table.print()

# cria dicionario com tamanho  primo
hash_table = SimpleHashTable(13)
hash_table.add(10, 10)
hash_table.add(20, 20)
hash_table.add(30, 30)
hash_table.add(40, 40)
hash_table.print()

"""Via de regra, números primos são tipicamente usados para oferecer certa uniformidade às colisões quando a população de chaves apresenta certas características matemáticas (tais como serem múltiplos de determinado número).

Se o número de buckets (entradas na tabela) e a polulação de chaves compartilham um fator comum, todas as chaves da população irão ser mapeadas para um bucket que seja múltiplo desse fator comum.

------------------------
Agora vamos encher a tabela!

Perceba que alguns números e dados não serão inseridos...
"""

# perceba que alguns
for i in range(1,20):
    if hash_table.add(i, f"valor {i}") != -1:
        print(f"valor {i} inserido com sucesso")
    else:
        print(f"ERRO ao inserir valor {i}")

hash_table.print()

"""-----------------
Exercício 1
====

A classe SimpleHashTable fornecida pelo professor tem dois métodos vazios: 

- resize_on_new(): aumenta ou diminui a tabela, usando uma nova região de memória 
- resize_in_situ(): aumenta ou diminui a tabela, usando a mesma região de memória

Elas servem, justamente, para você atualizar o tamanho da tabela quando ela fica cheia (aumentando-a) ou quando está muito vazia (diminuindo-a).

Implemente essas duas funções. Depois, use-as para atualizar o tamanho da estrutura e execute novamente o código que insere 20 valores. Mostre que suas funções (de resize on new ou in situ) funcionam. 
"""

#cria uma estrutura com 20 posições
tamanhoDicionario = 13
tamanhoDicionariofinal = 2 * tamanhoDicionario
hash_table = SimpleHashTable(tamanhoDicionario)

# perceba que alguns
for i in range(0,20):
    if hash_table.add(i, f"valor {i}") != -1:
        print(f"valor {i} inserido com sucesso")
    else:
        hash_table = hash_table.resize_in_situ(tamanhoDicionariofinal)
        hash_table.add(i, f"valor {i}")
hash_table.print()

i=tamanhoDicionariofinal-1
while hash_table.free[i] == True:
    hash_table = hash_table.resize_on_new(i)
    i -= 1

hash_table.print()

#cria uma estrutura com 20 posições
tamanhoDicionario = 13
tamanhoDicionariofinal = 20
hash_table = SimpleHashTable(tamanhoDicionario)

# perceba que alguns
for i in range(0,tamanhoDicionariofinal-1):
    if hash_table.add(i, f"valor {i}") != -1:
        print(f"valor {i} inserido com sucesso")
    else:
        hash_table = hash_table.resize_on_new((i)+1)
        hash_table.add(i, f"valor {i}")
hash_table.print()

"""------------
## Funções de hash para outros tipos de dados

Nossa SimpleHashTable foi feita de maneira a aceitar somente números inteiros como chaves. Mas, como vimos nos exemplos de Python, outros tipos de chave poderiam ser utilizados.

Vamos criar (e testar) uma função que recebe uma string e a transforma em um número:
"""

# recebe uma string e devolve um numero que é o valor acumulado de seus códigos ASCII
def hash_stri1(string):
    acc = 0
    for i in range(0, len(string)):
        acc = acc + ord(string[i])        
    return acc

hash_stri1("aaaa")

hash_stri1("abab")

hash_stri1("baab")

hash_stri1("zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz")

"""Perceba que essa função tem 2 problemas:

1. toda chave que possui a mesma combinação de caracteres, em posições diferentes, gera a mesma chave!
2. como os endereços gerados correspondem à soma de valores, essa soma pode ter diferentes tamanhos (casas). Não há um limite para seu tamanho, estando essa soma limitada ao tamanho dos números inteiros.

O primeiro problema pode gerar colisões e seria interessante resolvê-lo

O segundo problema não é tão grave, pois podemos aplicar uma segunda função hash que mapeia os números inteiros gerados para uma faixa de valores (tal como fizemos com a função módulo nos primeiros exemplos). Mas a função módulo pode gerar colisões demais e seria interessante termos uma função que evita isso já na geração do primeiro valor.

Além disso, se desejássemos usar outros tipos de dados como chave, teríamos que pensar em uma função para cada tipo, cada uma com suas respectivas heurísticas para gerar números com pouca repetição e com controle de tamanho. O ideal é que toda chave gerasse uma sequencia de bits de tamanho fixo, independente do seu tipo. 

Vamos ver como fazer isso em Python. 

A função 'bin()' converte um número em uma sequencia de bits (em uma string):
"""

bin(10)

bin(166)

"""Mas ela inclui o tipo da sequencia no início da string (veja que todos possuem '0b' no início)... Python faz isso para diferenciar sequencias de bits de sequencias em outras bases. Em hexadecimal o início seria '0h').

Mas isso é fácil de resolver:
"""

#devolve uma sugstring iniciando na posição 2:
bin(10)[2:]

"""Mas a função 'bin()' não funciona para strings... :-("""

# bin nao funciona para strings!
bin("aaaa")

"""Como sabemos programar, vamos criar uma que faça isso para nós! ;-)"""

def str_to_bin(string):
    resultado = ""
    for c in string:
        resultado = resultado + bin(ord(c))[2:]
    return resultado

str_to_bin("aaaa")

"""Podemos agora lidar como problema do tamanho. Uma maneira de limitar o tamanho é considerarmos todos os elementos como sendo sequencias de 8bit e combinarmos essas sequencias usando operadores booleanos. 

O exemplo seguinte combina dois-a-dois os caracteres de uma string, gerando sequencias de 8 bits:
"""

# não há função XOR para strings, então vamos criar uma:

# _xormap é um dicionário de combinações de bits e seu resultado em 'xor'
_xormap = {('0','1'):'1', ('1','0'):'1', ('1','1'):'0', ('0','0'):'0'}

# usa uma list compreensions para agrupar duas strings em uma lista de pares ordenados (zip)
# depois, para cada par (a,b) aplica o _xormap:
def xor(x, y):
    return ''.join([_xormap[a,b] for a,b in zip(x,y)])

# devolve uma sequencia de bits de tamanho fixo
def hash_str2(string):
    resultado = str_to_bin(string[0])
    for i in range(1, len(string)): # do segundo em diante
        str_tmp = str_to_bin(string[i])
        resultado = xor(resultado, str_tmp) # combina 2 a 2 usando Xor (bit a bit)
    return resultado

"""Vamos testá-la:"""

hash_str2("aaaaaa")

hash_str2("abaaaa")

hash_str2("abaaadddddddddda")

"""Mas ainda temos o problema de sequências que possuem os mesmos caracteres em posições diferentes gerarem o mesmo código:"""

hash_str2("aabaaa")

"""-----------------
Exercício 2
====

1. Crie uma Hash Table que aceite Strings como chaves, a StringHashTable, que gera um número a partir da combinação dos bytes dos caracteres de uma string. Faça com que ela gere sequencias ou números diferentes para sequencias que tenham o mesmo conjunto de letras em posições diferentes (i.e., "ABCD" == "BADC" == "DCBA" ....). Observe os slides da disciplina para um insight de como isso poderia ser feito (hashing parte 2).

2. E se precisássemos adicionar qualquer coisa como chave, como em Python, o que fazer? Tente criar uma estrutura que aceite qualquer coisa como chave: AnyHashTable.
"""

def hash_string(string):
    acc = 0
    for i in range(0, len(string)):
        acc = 32 * (acc + ord(string[i]) )       
    return acc

hash_string("ab")

hash_string("abdc")

hash_string("badc")

hash_string("dcba")

class AnyHashTable:
    # construtor, basta passar tamanho inicial da tabela hash
    def __init__(self, size):
        self.size = size
        self.dicionario = [-1] * size                 # -1 significa que o local está vago
        self.conteudo   = [None] * size 
        self.used       = [False] * size
        self.old = [True] * size
        self.free = [True] * size
        self.Realocado = [False] * size
        self.Ocupado = [False] * size
        self.ChaveStr = ['None'] * size
    
    def hash_str1(self, string):
      acc1 = 0
      for i in range(0, len(string)):
        acc1 = 32 * (acc1 + ord(string[i]) )       
      return acc1
        
    def add(self, chaveStr, dado):
        chaveStr = str(chaveStr)
        chave = self.hash_str1(chaveStr)
        posicao = posicao_inicial = chave % self.size # usa o módulo
        
        if self.dicionario[posicao] == -1:            # se estiver vazio
            self.dicionario[posicao] = chave          # coloca a chave
            self.conteudo[posicao] = dado                      # associa dado
            self.used[posicao] = True
            self.old[posicao] = True
            self.free[posicao] = False
            self.Ocupado[posicao] = True
            self.ChaveStr[posicao] = chaveStr
            return posicao
        else:                                         # se estiver ocupado, tenta achar lugar usando linear probing
            first_pass = True
            while posicao != posicao_inicial or first_pass:
                first_pass = False
                posicao = (posicao + 1) % self.size   # incrementa posição (mas fica dentro do intervalo do array de chaves)
                if self.dicionario[posicao] == -1:    
                    self.dicionario[posicao] = chave  
                    self.conteudo[posicao] = dado
                    self.used[posicao] = True
                    self.ChaveStr[posicao] = chaveStr
                    return posicao   
        if posicao == posicao_inicial:                  # se posicao igual à inicial é porque fez a volta e não achou
            return -1                                  # informa que deu problema (está cheio)
        else:   
            return posicao                             # retorna posição onde colocou o dado
    
    def get(self, ChaveStr):
        chaveStr = str(ChaveStr)
        chave = self.hash_str1(ChaveStr)
        posicao_inicial = posicao = chave % self.size
        first_pass = True
        
        # busca elemento usando linear probing:
        while self.dicionario[posicao] != chave and self.used and (posicao_inicial != posicao or first_pass):
            first_pass = False
            posicao = (posicao + 1) % self.size
            
        if self.dicionario[posicao] == chave:
            return self.conteudo[posicao]
        else:
            return None # se chegou aqui é porque não existe a chave
    
    def remove(self, ChaveStr):
        chaveStr = str(ChaveStr)
        chave = self.hash_str1(ChaveStr)
        posicao_inicial = posicao = chave % self.size
        first_pass = True
        
        # busca elemento usando linear probing:
        while self.dicionario[posicao] != chave and self.used and (posicao_inicial != posicao or first_pass):
            first_pass = False
            posicao = (posicao + 1) % self.size
            
        if self.dicionario[posicao] == chave:
            self.dicionario[posicao] = -1
            self.conteudo[posicao] = None
            self.ChaveStr[posicao] = "None"
            self.free[posicao] = True
            self.Ocupado[posicao] = False
            self.used[posicao] = False
            return posicao
        else:
            return None # se chegou aqui é porque não existe a chave
        return -1

    def print(self):
        for indice in range(0, self.size):
            print(f"({indice:03d})[{(self.ChaveStr[indice])}] = {str(self.conteudo[indice]):15s} ({self.used[indice]}) ({self.free[indice]})")

hash_table = AnyHashTable(10)
hash_table.print()

hash_table.add(41, 10)
hash_table.add("Leandro", 50)
hash_table.add("Fabricio", "120")
hash_table.add("Jackson", "Yan")
hash_table.add("Pedro", 120)
hash_table.add(1.32, 120)
hash_table.print()

hash_table.remove("Pedro")
hash_table.print()

hash_table.get("Leandro")